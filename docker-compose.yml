# Production Docker Compose for bare-metal deployment
# Copy to /opt/deadonfilm/docker-compose.yml on the server

services:
  agent:
    container_name: newrelic-infra
    build:
      context: .
      dockerfile: newrelic-infra.dockerfile
    cap_add:
      - SYS_PTRACE
    pid: host
    privileged: true
    environment:
      # New Relic Infrastructure agent configuration via environment variables
      # See: https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/configuration/infrastructure-agent-configuration-settings/
      - NRIA_LICENSE_KEY=${NEW_RELIC_LICENSE_KEY}
      - NRIA_DISPLAY_NAME=deadonfilm-server
      # PostgreSQL credentials for monitoring
      - POSTGRES_USER=${POSTGRES_USER:-deadonfilm}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB:-deadonfilm}
    volumes:
      - "/:/host:ro"
      - "/var/run/docker.sock:/var/run/docker.sock"
      - "./newrelic-postgres-config.yml:/etc/newrelic-infra/integrations.d/postgresql-config.yml:ro"
      - "./newrelic-redis-config.yml:/etc/newrelic-infra/integrations.d/redis-config.yml:ro"
      - "./newrelic-nginx-config.yml:/etc/newrelic-infra/integrations.d/nginx-config.yml:ro"
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "/usr/bin/newrelic-infra", "-validate"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 256M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  db:
    image: postgres:16-alpine
    container_name: deadonfilm-db
    restart: unless-stopped
    ports:
      - "5437:5432"
    environment:
      - POSTGRES_USER=${POSTGRES_USER:-deadonfilm}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB:-deadonfilm}
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgresql.conf:/etc/postgresql/postgresql.conf:ro
    command: postgres -c config_file=/etc/postgresql/postgresql.conf
    shm_size: '5gb'  # shared_buffers (4GB) + overhead for locks, connections
    deploy:
      resources:
        limits:
          memory: 6G
        reservations:
          memory: 2G
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-deadonfilm} -d ${POSTGRES_DB:-deadonfilm}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  app:
    image: ghcr.io/chenders/deadonfilm:${IMAGE_TAG:-latest}
    container_name: deadonfilm-app
    restart: unless-stopped
    expose:
      - "8080"
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - PORT=8080
      - TZ=America/Los_Angeles
      # DATABASE_URL is set here to use the db container; this overrides any value from .env file
      - DATABASE_URL=postgresql://${POSTGRES_USER:-deadonfilm}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-deadonfilm}
      - REDIS_URL=redis://redis:6379
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    volumes:
      - sitemap-data:/app/sitemaps
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '4'
        reservations:
          memory: 512M
    logging:
      driver: journald
      options:
        tag: "deadonfilm-app"
        labels: "service"

  nginx:
    image: ghcr.io/chenders/deadonfilm:${IMAGE_TAG:-latest}
    container_name: deadonfilm-nginx
    restart: unless-stopped
    entrypoint: ["nginx", "-g", "daemon off;"]
    ports:
      - "3000:3000"
    depends_on:
      app:
        condition: service_healthy
    volumes:
      - sitemap-data:/app/sitemaps:ro
    healthcheck:
      # Use 127.0.0.1 to avoid DNS resolution issues in container
      test: ["CMD", "wget", "-q", "--spider", "-T", "5", "http://127.0.0.1:3000/nginx-health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    deploy:
      resources:
        limits:
          memory: 128M
        reservations:
          memory: 64M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

  cron:
    image: ghcr.io/chenders/deadonfilm:${IMAGE_TAG:-latest}
    container_name: deadonfilm-cron
    restart: unless-stopped
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        echo "Creating crontab..."
        cat > /tmp/crontab << 'EOF'
        SHELL=/bin/sh
        PATH=/usr/local/bin:/usr/bin:/bin
        # TMDB sync - every 2 hours
        0 */2 * * * cd /app/server && node --import newrelic/esm-loader.mjs dist/scripts/sync-tmdb-changes.js
        # Sitemap generation - daily at 6 AM UTC
        0 6 * * * cd /app/server && node --import newrelic/esm-loader.mjs dist/scripts/sitemap-generate.js
        # Movie seeding - weekly Sunday 4 AM UTC
        0 4 * * 0 cd /app/server && node --import newrelic/esm-loader.mjs dist/scripts/seed-movies.js $(($(date +%Y)-1)) $(date +%Y) --count 500
        # Find uncertain deaths - weekly Sunday 5 AM UTC
        0 5 * * 0 cd /app/server && node --import newrelic/esm-loader.mjs dist/scripts/find-uncertain-deaths.js 2>&1 | head -100
        EOF
        # Strip leading spaces from heredoc (YAML adds 8 spaces)
        sed -i 's/^[[:space:]]*//' /tmp/crontab
        echo "Crontab contents:"
        cat /tmp/crontab
        echo "Starting supercronic..."
        # Use full path so os.Args[0] is absolute path when supercronic forks itself for reaping
        exec /usr/local/bin/supercronic /tmp/crontab
    env_file:
      - .env
    environment:
      - NODE_ENV=production
      - TZ=America/Los_Angeles
      - DATABASE_URL=postgresql://${POSTGRES_USER:-deadonfilm}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-deadonfilm}
      - REDIS_URL=redis://redis:6379
      # PATH needed so supercronic can find itself when forking for process reaping
      - PATH=/usr/local/bin:/usr/bin:/bin
    healthcheck:
      # Use pidof instead of pgrep -x since busybox pgrep may not support -x flag
      test: ["CMD-SHELL", "pidof supercronic > /dev/null"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
    volumes:
      - sitemap-data:/app/sitemaps
    depends_on:
      app:
        condition: service_healthy
    deploy:
      resources:
        limits:
          memory: 512M
        reservations:
          memory: 128M
    logging:
      driver: journald
      options:
        tag: "deadonfilm-cron"
        labels: "service"

  redis:
    image: redis:7-alpine
    container_name: deadonfilm-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    # maxmemory=512mb + ~88MB headroom for Redis overhead within 600M container limit
    command: redis-server --appendonly yes --maxmemory 512mb --maxmemory-policy allkeys-lru
    deploy:
      resources:
        limits:
          memory: 600M
        reservations:
          memory: 256M
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

volumes:
  postgres-data:
  sitemap-data:
  redis-data:
